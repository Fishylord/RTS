use std::collections::HashMap;
use std::sync::mpsc::{Receiver, Sender};

//use crate::system_monitoring::LogEvent;

/// Recommendations generated by the Flow Analyzer for traffic light adjustments.
#[derive(Debug)]
pub enum Recommendation {
    AdjustGreenTime {
        lane_id: u32,
        new_green_time: u32,
        timestamp: u64,
    },
}

fn get_current_timestamp() -> u64 {
    use std::time::{SystemTime, UNIX_EPOCH};
    SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
}


pub fn run_flow_analyzer(analyzer_rx: Receiver<HashMap<u32, u32>>, rec_tx: Sender<Recommendation>) {
    let mut lane_vehicle_counts: HashMap<u32, u32> = HashMap::new();

    // Infinite loop to keep listening for new data
    loop {
        match analyzer_rx.recv() {
            Ok(lanes) => {
                lane_vehicle_counts = lanes.clone(); // Update lane vehicle counts

                for (&lane_id, &vehicle_count) in &lane_vehicle_counts {
                    if vehicle_count >= 4 { // Adjust the congestion threshold as needed
                        let rec = Recommendation::AdjustGreenTime {
                            lane_id,
                            new_green_time: 40, // Example new green time
                            timestamp: get_current_timestamp(),
                        };
                        println!("Congestion detected at lane {}", lane_id);

                        if let Err(e) = rec_tx.send(rec) {
                            println!("Error sending recommendation: {}", e);
                        }
                    }
                }
            }
            Err(_) => {
                println!("Analyzer: No more data. Exiting...");
                break; // Exit loop if channel is closed
            }
        }
    }
}

/*
/// Runs the Traffic Flow Analyzer.
/// It listens to simulation events, detects congestion based on a vehicle count threshold,
/// and sends recommendations to adjust traffic light timings.
pub fn run_flow_analyzer(analyzer_rx: Receiver<HashMap<u32,u32>>, rec_tx: Sender<Recommendation>) {
    // Store the latest vehicle counts per junction.
    let mut lane_vehicle_counts: HashMap<u32, u32> = HashMap::new();
    // Process incoming simulation events.
    while let Ok(lanes) = analyzer_rx.recv() {
        match event {
            SimEvent::TrafficSnapshot {} => {
                lane_vehicle_counts = lanes.clone();
                for (&lane_id, &vehicle_count) in &lane_vehicle_counts {
                    if vehicle_count > 4 { // If congestion detected
                        let rec = Recommendation::AdjustGreenTime {
                            lane_id,
                            new_green_time: 40, // Example: Adjust green light time
                            timestamp = get_current_timestamp(),  // âœ… Now timestamp is correctly extracted
                        };

                        rec_tx.send(rec).unwrap();
                    }

                    /*// Log that congestion was detected.
                    let log_event = LogEvent {
                        source: "FlowAnalyzer".to_string(),
                        message: format!("Congestion detected at junction {}: {} vehicles", junction, vehicle_count),
                        timestamp,
                    };*/

            _ => {
                // Other event types are ignored in this basic analyzer.
            }
        }
    }
}
*/